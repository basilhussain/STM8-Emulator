# STM8 Emulator

### About

This is an emulator for the STM8 microcontroller family, and it also is designed to be able to have various simulated products/hardware layouts that the STM8 MCU is attached to, so that GPIO and other functionality can be intercepted and dealt with as needed. There were some defined product designs, but I've removed them from this public release because they were all based on proprietary designs made by the company I work for.

This program can load ELF files generated by an STM8 compiler.

Few of the peripherals are emulated so far. I've been adding them as needed.

The solution and project files are made with Visual Studio 2019.


### Features

NOTE: More features can be added as the need arises.

EEPROM contents can be loaded and saved via a file with the -eeprom option.

#### Currently supported STM8 models:

- STM8S003F3 (Flash: 8 KB, RAM: 1 KB, EEPROM: 128 bytes)
- STM8S207S6 (Flash: 32 KB, RAM: 6 KB, EEPROM: 1 KB)
- STM8S207R8 (Flash: 64 KB, RAM: 6 KB, EEPROM: 2 KB)


#### Currently supported on-chip devices:

- GPIO ports
- CLK
- Analog-to-Digital converter (ADC)
- UART1
- UART3
- TIM2 timer

Emulated UARTs can be redirected through either the stdio console, a serial port, or a TCP socket (currently server-only).


#### Currently supported exeternal devices:

- Casil 1610 16-character LCD display (Incomplete. Cannot return data, but you can write characters to it)


#### Currently supported hardware products/designs:

- Null (No display unless a UART is redirected to the console. CPU runs in isolation.)

I may add a few ST Discovery boards in a future release as examples of how to add your own custom designs.


### Functional overview

The memory regions of the MCU are simulated with byte arrays which are defined in the header files for each MCU device model.

The CPU engine uses C variables to simulate the CPU registers PC, A, X, Y, SP and CC.

The ELF file generated by the STM8 C compiler is loaded into the correct region of memory, and the CPU engine steps through the memory locations, interpreting the instruction bytecode as the real CPU would. It performs equivalent operations and modifies the simulated registers as the real CPU would.

Memory accesses by the emulated CPU are intercepted, mapped and interpreted in different ways to simulate the various on-chip peripherals, as well as different external hardware on various product designs.



### Provided example ELF files

- dhrystone.elf - A port of Dhrystone for the STM8. Displays 0 as the result for some reason, have not spent time looking at why yet.
- monitor.elf - A very, very simple "monitor" firmware I started writing that currently just lets you examine memory contents. Uses UART1.
- uartlink.elf - Simple program to relay data between UART1 and UART3.



### Running an example ELF

Try something like:

STM8.exe -product null -cpu stm8s207r8 -uart3console -elf ELF\dhrystone.elf

or

STM8.exe -product null -cpu stm8s003f3 -uart1console -elf ELF\monitor.elf



### Still to do

- Add more MCU models, peripherals and product designs as needed
- Clean up code a bit, maybe rewrite CPU engine to take advantage of bit patterns in the opcodes
- Finish adding all of the real clock timings for each opcode.
